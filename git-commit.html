<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>git-commit</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/markdown-to-html-style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/mdn-article.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/medium-basic-export.css">




<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/github.css">
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/git.js"></script>


<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/highlight.pack.js"></script>
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/highlightJsWorker.js"></script>
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/highlightjs-badge.js"></script>
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/highlightjs-badge.min.js"></script>
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/jquery-1.10.1.min.js"></script>
<script async defer src="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/jquery-3.3.1.min.js"></script></head>
  <body>
    <h1 id="git-commit">Git Commit</h1>
    <p>
      <code>git commit</code> creates a commit, which is like a snapshot of your
      repository. These commits are snapshots of your entire repository at
      specific times. You should make new commits often, based around logical
      units of change. Over time, commits should tell a story of the history of
      your repository and how it came to be the way that it currently is.
      Commits include lots of metadata in addition to the contents and message,
      like the author, timestamp, and more.
    </p>
    <h2 id="how-git-commit-works">How Git Commit Works</h2>
    <p>
      Commits are the building blocks of “save points” within Git’s version
      control.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode sh"
      ><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">git</span> commit -m <span class="st">&quot;update the README.md with link to contributing guide&quot;</span></a></code></pre>
    </div>
    <h3 id="commits-shape-history">Commits shape history</h3>
    <p>
      By using commits, you’re able to craft history intentionally and safely.
      You can make commits to different branches, and specify exactly what
      changes you want to include. Commits are created on the branch that you’ve
      currently checked out to (wherever HEAD is pointing) so it’s always a good
      idea to run <code>git status</code> before making a commit, to check that
      you’re checked out to the branch that you intend to be. Before you commit,
      you will need to stage any new changes that you’d like to include in the
      commit using <code>git add [file]</code>.
    </p>
    <p>
      Commits are lightweight SHA hashes, objects within Git. As long as you’re
      working with text files, you won’t need to worry about how many files you
      have, how big they are, or how many commits you make. Git can handle it!
    </p>
    <h3 id="committing-in-two-phases">Committing in two phases</h3>
    <p>
      Commits have two phases to help you craft commits properly. Commits should
      be logical, atomic units of change that represent a specific idea. But,
      not all humans work that way. You may get carried away and end up solving
      two or three problems before you remember to commit! That’s OK - Git can
      handle that. Once you’re ready to craft your commits, you’ll use
      <code>git add &lt;FILENAME&gt;</code> to specify the files that you’d like
      to “stage” for commit. Without adding any files, the command
      <code>git commit</code> won’t work. Git only looks to the staging area to
      find out what to commit. Staging, or adding, files, is possible through
      the command line, and also possible with most Git interfaces like GitHub
      Desktop by selecting the lines or files that you’d like to stage.
    </p>
    <p>
      You can also use a handy command, <code>git add -p</code>, to walk through
      the changes and separate them, even if they’re in the same file.
    </p>
    <h2 id="how-to-use-git-commit">How to Use Git Commit</h2>
    <h3 id="common-usages-and-options-for-git-commit">
      Common usages and options for Git Commit
    </h3>
    <ul>
      <li>
        <code>git commit</code>: This starts the commit process, but since it
        doesn’t include a <code>-m</code> flag for the message, your default
        text editor will be opened for you to create the commit message. If you
        haven’t configured anything, there’s a good chance this will be VI or
        Vim. (To get out, press Esc, then <code>:wq</code>, and then Enter.
        :wink:)
      </li>
      <li>
        <code>git commit -m "descriptive commit message"</code>: This starts the
        commit process, and allows you to include the commit message at the same
        time.
      </li>
      <li>
        <code>git commit -am "descriptive commit message"</code>: In addition to
        including the commit message, this option allows you to skip the staging
        phase. The addition of <code>-a</code> will automatically stage any
        files that are already being tracked by Git (changes to files that
        you’ve committed before).
      </li>
      <li>
        <code>git commit --amend</code>: Replaces the most recent commit with a
        new commit. (More on this later!)
      </li>
    </ul>
    <p>
      To see all of the possible options you have with <code>git commit</code>,
      check out
      <a href="https://git-scm.com/docs/git-commit">Git’s documentation</a>.
    </p>
    <h3 id="how-to-undo-commits-in-git">How to Undo Commits in Git</h3>
    <p>
      Sometimes, you may need to change history. You may need to undo a commit.
      If you find yourself in this situation, there are a few very important
      things to remember:
    </p>
    <ul>
      <li>
        If you are “undoing” a commit that exists on the remote, you could
        create big problems for your collaborators
      </li>
      <li>Undoing a commit on work that you only have locally is much safer</li>
    </ul>
    <h3 id="what-can-go-wrong-while-changing-history">
      What can go wrong while changing history?
    </h3>
    <p>
      Changing history for collaborators can be problematic in a few ways.
      Imagine - You and another collaborator have the same repository, with the
      same history. But, they make a change that <em>deletes</em> the most
      recent commit. They continue new commits from the commit directly before
      that. Meanwhile, you keep working <em>with</em> the commit that the
      collaborator tried to delete. When they push, they’ll have to ‘force
      push’, which should show to them that they’re changing history.
      <strong>What do you think will happen when you try to push?</strong>
    </p>
    <p>
      In dramatic cases, Git may decide that the histories are too different and
      the projects are no longer related. This is uncommon, but a big problem.
    </p>
    <p>
      The most common result is that your <code>git push</code> would return the
      “deleted” commit to a shared history. (First, you would
      <code>git pull</code> if you were working on the same branch, and then
      merge, but the results would be the same.) This means that whatever was so
      important to delete is now back in the repository. A password, token, or
      large binary file may return without ever alerting you.
    </p>
    <h4 id="git-revert"><code>git revert</code></h4>
    <p>
      <code>git revert</code> is the safest way to change history with Git.
      Instead of deleting existing commits, <code>git revert</code> looks at the
      changes introduced in a specific commit, then applies the inverse of those
      changes in a new commit. It functions as an “undo commit” command, without
      sacrificing the integrity of your repository’s history.
      <strong
        ><code>git revert</code> is always the recommended way to change history
        when it’s possible</strong
      >.
    </p>
    <h4 id="git-reset"><code>git reset</code></h4>
    <p>
      Sometimes, a commit includes sensitive information that actually needs to
      be deleted. <code>git reset</code> is a very powerful command that may
      cause you to lose work. By resetting, you move the
      <code>HEAD</code> pointer and the branch pointer to another point in time
      - maybe making it seem like the commits in between never happened! Before
      using <code>git reset</code>:
    </p>
    <ul>
      <li>Make sure to talk with your team about any shared commits</li>
      <li>
        Research the three types of reset to see which is right for you (–soft,
        –mixed, –hard)
      </li>
      <li>
        Commit any work that you don’t want to be lost intentionally - work that
        is committed can be gotten back, but uncommitted work cannot
      </li>
    </ul>
    <h4 id="git-reflog"><code>git reflog</code></h4>
    <p>
      If you’re changing history and undoing commits, you should know about
      <code>git reflog</code>. If you get into trouble, the reflog could get you
      out of trouble. The reflog is a log of every commit that
      <code>HEAD</code> has pointed to. So, for example, if you use
      <code>git reset</code> and unintentionally lose commits, you can find and
      access them with <code>git reflog</code>.
    </p>
    <h3 id="updating-commits-with-git-commit-amend">
      Updating Commits With Git Commit Amend
    </h3>
    <p>
      While <code>git commit --amend</code> does change history, it only changes
      the most recent commit on your current branch. This can be an extremely
      useful command for commits that:
    </p>
    <ul>
      <li>Haven’t been pushed to the remote yet</li>
      <li>Have a spelling error in the commit message</li>
      <li>Don’t contain the changes that you’d like to contain</li>
    </ul>
    <h2 id="examples-of-git-commit">Examples of Git Commit</h2>
    <p>
      Once you’ve staged the files that you want to include in your commit,
      you’re ready. Whether you commit in a tool like GitHub Desktop, or through
      your command line, the commit message is important. Commit messages should
      be short and descriptive of your change. If you are looking through your
      repository’s history, you’ll be guided by the commit messages, so they
      should tell a story. Commits in the command line can include the message
      with the following format:
    </p>
    <ul>
      <li><code>git commit -m "git commit message example"</code></li>
    </ul>
    <p>
      Commit messages should be present tense and directive, like the following
      examples:
    </p>
    <ul>
      <li><code>git commit -m "create file structure for Git guides"</code></li>
      <li>
        <code>git commit -m "translate Git cheat sheet into German"</code>
      </li>
      <li><code>git commit -m "update broken URL to Git resources"</code></li>
    </ul>
    <p>
      If you’d like to include more context in your commit messages, you can
      also include an extended commit message.
    </p>
    <h2 id="related-commands">Related commands</h2>
    <ul>
      <li>
        <code>git add [file]</code>: Snapshots the file in preparation for
        versioning, adding it to the staging area.
      </li>
      <li>
        <code>git status</code>: Always a good idea, this command shows you what
        branch you’re on, what files are in the working or staging directory,
        and any other important information.
      </li>
      <li>
        <code>git push</code>: Uploads all local branch commits to the remote.
      </li>
      <li>
        <code>git log</code>: Browse and inspect the evolution of project files.
      </li>
    </ul>
  </body>
</html>
